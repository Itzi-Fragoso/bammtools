node
bt[as.character(node)]
maxpossible
max(bt) - start.time
((max(bt) - start.time) > bt[as.character(node)])
bt[as.character(node)]
max(bt) - bt[as.character(node)]
phytools::nodeHeights(whales,141)
require(phytool)
require(phytools)
nodeHeights(tree)
nodeHeights(wha;es)
nodeHeights(whales)
?nodeHeights
which(whales$edge[,1] == 141)
nodeHeights(whales)[c(107,120),]
cat("Warning: start.time occurs before node to include. Start.time has been changed to location of included node.\n")
cat("Warning: start.time occurs before the age of the node to include. Start.time has been changed to location of included node.\n")
?getRateThroughTimeMatrix
start.time <- max(bt);
end.time <- 0;
tvec <- seq(start.time, end.time, length.out= nslices);
tvec
nslices
nslices=10
goodTime <- function (vec, val, tol) {#
		(vec[,2] - val <= tol) & (val - vec[,3] <= tol);#
	}
length(ephy$eventBranchSegs)
ephy
counter=1
es <- ephy$eventBranchSegs[[counter]];
events <- ephy$eventData[[counter]];
isGoodNode <- rep(TRUE, nrow(es));
tvec
tvec <- seq(start.time, end.time, length.out = nslices);
tvec
es
events
isGoodNode
tvec[3]
tvec[3]->x
isGoodTime <- goodTime(es, time, tol=tol);
es
x
x->time
isGoodTime <- goodTime(es, time, tol=tol);
isGoodTime
is.null(node)
node=NULL
if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}#
	bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);#
#
	if (is.null(start.time)) {#
		start.time <- max(bt);#
	}#
	if (is.null(end.time)) {#
		end.time <- 0;#
	}
tvec <- seq(start.time, end.time, length.out = nslices);#
	#tol = 1*10^-decimals(ephy$eventBranchSegs[[1]][1,2]);#
	tol <- 0.00001#
	goodTime <- function (vec, val, tol) {#
		(vec[,2] - val <= tol) & (val - vec[,3] <= tol);#
	}
counter
es <- ephy$eventBranchSegs[[counter]];
events <- ephy$eventData[[counter]];
isGoodNode <- rep(TRUE, nrow(es));
time<-tvec[3]
isGoodTime <- goodTime(es, time, tol=tol);
isGoodTime
head(es)
!(is.null(node))
estemp <- es[isGoodTime & isGoodNode, ];
estemp
if (is.vector(estemp)) {#
			index <- estemp[4];#
		} else {#
			index <- estemp[,4];#
		}
time
events$time[index]
tvv <- time - events$time[index];
tvv
?exponentialRate
exponentialRate
##############################################################
##
#	getRateThroughTimeMatrix(....)#
#	#
#	include or exclude options:#
#	start.time		=	 start time (in units before present)#
#						 if NULL, starts at root#
#	end.time		=	 end time #
#						 if NULL, ends at present#
#	nslices			=	 number of time cuts#
#	Return#
#	list with components:#
#					$times	= the time vector#
#					$lambda = speciation rate matrix#
#					$mu 	= extinction rate matrix#
# 					$type   = diversification or trait (needs to be extended to trait data)		#
# returns object of class bamm-ratematrix#
#	 #
#
getRateThroughTimeMatrix2 <- function(ephy, start.time=NULL, end.time=NULL, nslices=100, node=NULL, nodetype = 'include') {#
	if (!'bammdata' %in% class(ephy)) {#
		stop("Object ephy must be of class 'bammdata'\n");#
	}#
	if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}#
	bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);#
#
	if (is.null(start.time)) {#
		start.time <- max(bt);#
	}#
	if (is.null(end.time)) {#
		end.time <- 0;#
	}#
	tvec <- seq(start.time, end.time, length.out = nslices);#
	#tol = 1*10^-decimals(ephy$eventBranchSegs[[1]][1,2]);#
	tol <- 0.00001#
	goodTime <- function (vec, val, tol) {#
		(vec[,2] - val <= tol) & (val - vec[,3] <= tol);#
	}#
	getRates <- function(time, es, events, isGoodNode) {#
		isGoodTime <- goodTime(es, time, tol=tol);#
		if (!(is.null(node))) { # only enter this if not the root. otherwise, only have to set once per i.#
			isGoodNode <- es[,1] %in% nodeset;	#
		}#
		estemp <- es[isGoodTime & isGoodNode, ];#
		if (is.vector(estemp)) {#
			index <- estemp[4];#
		} else {#
			index <- estemp[,4];#
		}#
		tvv <- time - events$time[index];#
		rates <- exponentialRate(tvv, events$lam1[index], events$lam2[index]);#
		return(list(rates,index));#
	}#
#
	bySample <- function(counter, ephy) {#
		es <- ephy$eventBranchSegs[[counter]];#
		events <- ephy$eventData[[counter]];#
		isGoodNode <- rep(TRUE, nrow(es));#
		ret <- lapply(tvec, function(x) getRates(time = x, es, events, isGoodNode));#
		mmRow <- unlist(lapply(ret, function(x) mean(x[[1]])));#
		mumatRow <- unlist(lapply(ret, function(x) mean(events$mu1[x[[2]]])));#
		return(list(mmRow,mumatRow));#
	}#
	ret <- lapply(1:length(ephy$eventBranchSegs), function(y) bySample(y, ephy));#
	mm <- lapply(ret, function(x) x[[1]]);#
	mm <- do.call(rbind, mm);#
	mumat <- lapply(ret, function(x) x[[2]]);#
	mumat <- do.call(rbind, mumat);#
	obj <- list();#
	if (ephy$type == 'diversification') {#
		obj$lambda <- mm;#
		obj$mu <- mumat;#
	}#
	if (ephy$type == 'trait') {#
		obj$beta <- mm;#
	}#
	obj$times <- tvec;#
	class(obj) <- 'bamm-ratematrix';#
	if (ephy$type=='diversification') {#
		obj$type = 'diversification';#
	} else {#
		obj$type = 'trait';	#
	}#
	return(obj);#
}
getRateThroughTimeMatrix(ephy)->old
getRateThroughTimeMatrix2(ephy)->new
all.equal(old,new)
names(old)
all.equal(old$lambda,new$lambda)
##############################################################
##
#	getRateThroughTimeMatrix(....)#
#	#
#	include or exclude options:#
#	start.time		=	 start time (in units before present)#
#						 if NULL, starts at root#
#	end.time		=	 end time #
#						 if NULL, ends at present#
#	nslices			=	 number of time cuts#
#	Return#
#	list with components:#
#					$times	= the time vector#
#					$lambda = speciation rate matrix#
#					$mu 	= extinction rate matrix#
# 					$type   = diversification or trait (needs to be extended to trait data)		#
# returns object of class bamm-ratematrix#
#	 #
#
getRateThroughTimeMatrix2 <- function(ephy, start.time=NULL, end.time=NULL, nslices=100, node=NULL, nodetype = 'include') {#
	if (!'bammdata' %in% class(ephy)) {#
		stop("Object ephy must be of class 'bammdata'\n");#
	}#
	if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}#
	bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);#
#
	if (is.null(start.time)) {#
		start.time <- max(bt);#
	}#
	if (is.null(end.time)) {#
		end.time <- 0;#
	}#
	tvec <- seq(start.time, end.time, length.out = nslices);#
	#tol = 1*10^-decimals(ephy$eventBranchSegs[[1]][1,2]);#
	tol <- 0.00001#
	goodTime <- function (vec, val, tol) {#
		(vec[,2] - val <= tol) & (val - vec[,3] <= tol);#
	}#
	getRates <- function(time, es, events, isGoodNode) {#
		isGoodTime <- goodTime(es, time, tol=tol);#
		if (!(is.null(node))) { # only enter this if not the root. otherwise, only have to set once per i.#
			isGoodNode <- es[,1] %in% nodeset;	#
		}#
		estemp <- es[isGoodTime & isGoodNode, ];#
		if (is.vector(estemp)) {#
			index <- estemp[4];#
		} else {#
			index <- estemp[,4];#
		}#
		#tvv <- time - events$time[index];#
		tvv <- events$time[index];#
		rates <- exponentialRate(tvv, events$lam1[index], events$lam2[index]);#
		return(list(rates,index));#
	}#
#
	bySample <- function(counter, ephy) {#
		es <- ephy$eventBranchSegs[[counter]];#
		events <- ephy$eventData[[counter]];#
		isGoodNode <- rep(TRUE, nrow(es));#
		ret <- lapply(tvec, function(x) getRates(time = x, es, events, isGoodNode));#
		mmRow <- unlist(lapply(ret, function(x) mean(x[[1]])));#
		mumatRow <- unlist(lapply(ret, function(x) mean(events$mu1[x[[2]]])));#
		return(list(mmRow,mumatRow));#
	}#
	ret <- lapply(1:length(ephy$eventBranchSegs), function(y) bySample(y, ephy));#
	mm <- lapply(ret, function(x) x[[1]]);#
	mm <- do.call(rbind, mm);#
	mumat <- lapply(ret, function(x) x[[2]]);#
	mumat <- do.call(rbind, mumat);#
	obj <- list();#
	if (ephy$type == 'diversification') {#
		obj$lambda <- mm;#
		obj$mu <- mumat;#
	}#
	if (ephy$type == 'trait') {#
		obj$beta <- mm;#
	}#
	obj$times <- tvec;#
	class(obj) <- 'bamm-ratematrix';#
	if (ephy$type=='diversification') {#
		obj$type = 'diversification';#
	} else {#
		obj$type = 'trait';	#
	}#
	return(obj);#
}
getRateThroughTimeMatrix2(ephy)->new
all.equal(old$lambda,new$lambda)
##############################################################
##
#	getRateThroughTimeMatrix(....)#
#	#
#	include or exclude options:#
#	start.time		=	 start time (in units before present)#
#						 if NULL, starts at root#
#	end.time		=	 end time #
#						 if NULL, ends at present#
#	nslices			=	 number of time cuts#
#	Return#
#	list with components:#
#					$times	= the time vector#
#					$lambda = speciation rate matrix#
#					$mu 	= extinction rate matrix#
# 					$type   = diversification or trait (needs to be extended to trait data)		#
# returns object of class bamm-ratematrix#
#	 #
#
getRateThroughTimeMatrix2 <- function(ephy, start.time=NULL, end.time=NULL, nslices=100, node=NULL, nodetype = 'include') {#
	if (!'bammdata' %in% class(ephy)) {#
		stop("Object ephy must be of class 'bammdata'\n");#
	}#
	if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}#
	bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);#
#
	if (is.null(start.time)) {#
		start.time <- max(bt);#
	}#
	if (is.null(end.time)) {#
		end.time <- 0;#
	}#
	tvec <- seq(start.time, end.time, length.out = nslices);#
	#tol = 1*10^-decimals(ephy$eventBranchSegs[[1]][1,2]);#
	tol <- 0.00001#
	goodTime <- function (vec, val, tol) {#
		(vec[,3] - val <= tol) & (val - vec[,2] <= tol);#
	}#
	getRates <- function(time, es, events, isGoodNode) {#
		isGoodTime <- goodTime(es, time, tol=tol);#
		if (!(is.null(node))) { # only enter this if not the root. otherwise, only have to set once per i.#
			isGoodNode <- es[,1] %in% nodeset;	#
		}#
		estemp <- es[isGoodTime & isGoodNode, ];#
		if (is.vector(estemp)) {#
			index <- estemp[4];#
		} else {#
			index <- estemp[,4];#
		}#
		tvv <- time - events$time[index];#
		rates <- exponentialRate(tvv, events$lam1[index], events$lam2[index]);#
		return(list(rates,index));#
	}#
#
	bySample <- function(counter, ephy) {#
		es <- ephy$eventBranchSegs[[counter]];#
		events <- ephy$eventData[[counter]];#
		isGoodNode <- rep(TRUE, nrow(es));#
		ret <- lapply(tvec, function(x) getRates(time = x, es, events, isGoodNode));#
		mmRow <- unlist(lapply(ret, function(x) mean(x[[1]])));#
		mumatRow <- unlist(lapply(ret, function(x) mean(events$mu1[x[[2]]])));#
		return(list(mmRow,mumatRow));#
	}#
	ret <- lapply(1:length(ephy$eventBranchSegs), function(y) bySample(y, ephy));#
	mm <- lapply(ret, function(x) x[[1]]);#
	mm <- do.call(rbind, mm);#
	mumat <- lapply(ret, function(x) x[[2]]);#
	mumat <- do.call(rbind, mumat);#
	obj <- list();#
	if (ephy$type == 'diversification') {#
		obj$lambda <- mm;#
		obj$mu <- mumat;#
	}#
	if (ephy$type == 'trait') {#
		obj$beta <- mm;#
	}#
	obj$times <- tvec;#
	class(obj) <- 'bamm-ratematrix';#
	if (ephy$type=='diversification') {#
		obj$type = 'diversification';#
	} else {#
		obj$type = 'trait';	#
	}#
	return(obj);#
}
getRateThroughTimeMatrix2(ephy)->new
all.equal(old$lambda,new$lambda)
##############################################################
##
#	getRateThroughTimeMatrix(....)#
#	#
#	include or exclude options:#
#	start.time		=	 start time (in units before present)#
#						 if NULL, starts at root#
#	end.time		=	 end time #
#						 if NULL, ends at present#
#	nslices			=	 number of time cuts#
#	Return#
#	list with components:#
#					$times	= the time vector#
#					$lambda = speciation rate matrix#
#					$mu 	= extinction rate matrix#
# 					$type   = diversification or trait (needs to be extended to trait data)		#
# returns object of class bamm-ratematrix#
#	 #
#
getRateThroughTimeMatrix2 <- function(ephy, start.time=NULL, end.time=NULL, nslices=100, node=NULL, nodetype = 'include') {#
	if (!'bammdata' %in% class(ephy)) {#
		stop("Object ephy must be of class 'bammdata'\n");#
	}#
	if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}#
	bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);#
#
	if (is.null(start.time)) {#
		start.time <- max(bt);#
	}#
	if (is.null(end.time)) {#
		end.time <- 0;#
	}#
	tvec <- seq(start.time, end.time, length.out = nslices);#
	#tol = 1*10^-decimals(ephy$eventBranchSegs[[1]][1,2]);#
	tol <- 0.00001#
	goodTime <- function (vec, val, tol) {#
		(vec[,3] - val <= tol) & (val - vec[,2] <= tol);#
	}#
	getRates <- function(time, es, events, isGoodNode) {#
		isGoodTime <- goodTime(es, time, tol=tol);#
		if (!(is.null(node))) { # only enter this if not the root. otherwise, only have to set once per i.#
			isGoodNode <- es[,1] %in% nodeset;	#
		}#
		estemp <- es[isGoodTime & isGoodNode, ];#
		if (is.vector(estemp)) {#
			index <- estemp[4];#
		} else {#
			index <- estemp[,4];#
		}#
		#tvv <- time - events$time[index];#
		tvv <- events$time[index];#
		rates <- exponentialRate(tvv, events$lam1[index], events$lam2[index]);#
		return(list(rates,index));#
	}#
#
	bySample <- function(counter, ephy) {#
		es <- ephy$eventBranchSegs[[counter]];#
		events <- ephy$eventData[[counter]];#
		isGoodNode <- rep(TRUE, nrow(es));#
		ret <- lapply(tvec, function(x) getRates(time = x, es, events, isGoodNode));#
		mmRow <- unlist(lapply(ret, function(x) mean(x[[1]])));#
		mumatRow <- unlist(lapply(ret, function(x) mean(events$mu1[x[[2]]])));#
		return(list(mmRow,mumatRow));#
	}#
	ret <- lapply(1:length(ephy$eventBranchSegs), function(y) bySample(y, ephy));#
	mm <- lapply(ret, function(x) x[[1]]);#
	mm <- do.call(rbind, mm);#
	mumat <- lapply(ret, function(x) x[[2]]);#
	mumat <- do.call(rbind, mumat);#
	obj <- list();#
	if (ephy$type == 'diversification') {#
		obj$lambda <- mm;#
		obj$mu <- mumat;#
	}#
	if (ephy$type == 'trait') {#
		obj$beta <- mm;#
	}#
	obj$times <- tvec;#
	class(obj) <- 'bamm-ratematrix';#
	if (ephy$type=='diversification') {#
		obj$type = 'diversification';#
	} else {#
		obj$type = 'trait';	#
	}#
	return(obj);#
}
getRateThroughTimeMatrix2(ephy)->new
all.equal(old$lambda,new$lambda)
head(new$lambda)
##############################################################
##
#	getRateThroughTimeMatrix(....)#
#	#
#	include or exclude options:#
#	start.time		=	 start time (in units before present)#
#						 if NULL, starts at root#
#	end.time		=	 end time #
#						 if NULL, ends at present#
#	nslices			=	 number of time cuts#
#	Return#
#	list with components:#
#					$times	= the time vector#
#					$lambda = speciation rate matrix#
#					$mu 	= extinction rate matrix#
# 					$type   = diversification or trait (needs to be extended to trait data)		#
# returns object of class bamm-ratematrix#
#	 #
#
getRateThroughTimeMatrix2 <- function(ephy, start.time=NULL, end.time=NULL, nslices=100, node=NULL, nodetype = 'include') {#
	if (!'bammdata' %in% class(ephy)) {#
		stop("Object ephy must be of class 'bammdata'\n");#
	}#
	if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}#
	bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);#
#
	if (is.null(start.time)) {#
		start.time <- max(bt);#
	}#
	if (is.null(end.time)) {#
		end.time <- 0;#
	}#
	tvec <- seq(start.time, end.time, length.out = nslices);#
	#tol = 1*10^-decimals(ephy$eventBranchSegs[[1]][1,2]);#
	tol <- 0.00001#
	goodTime <- function (vec, val, tol) {#
		(vec[,2] - val <= tol) & (val - vec[,3] <= tol);#
	}#
	getRates <- function(time, es, events, isGoodNode) {#
		isGoodTime <- goodTime(es, time, tol=tol);#
		if (!(is.null(node))) { # only enter this if not the root. otherwise, only have to set once per i.#
			isGoodNode <- es[,1] %in% nodeset;	#
		}#
		estemp <- es[isGoodTime & isGoodNode, ];#
		if (is.vector(estemp)) {#
			index <- estemp[4];#
		} else {#
			index <- estemp[,4];#
		}#
		#tvv <- time - events$time[index];#
		tvv <- events$time[index];#
		rates <- exponentialRate(tvv, events$lam1[index], events$lam2[index]);#
		return(list(rates,index));#
	}#
#
	bySample <- function(counter, ephy) {#
		es <- ephy$eventBranchSegs[[counter]];#
		events <- ephy$eventData[[counter]];#
		isGoodNode <- rep(TRUE, nrow(es));#
		ret <- lapply(tvec, function(x) getRates(time = x, es, events, isGoodNode));#
		mmRow <- unlist(lapply(ret, function(x) mean(x[[1]])));#
		mumatRow <- unlist(lapply(ret, function(x) mean(events$mu1[x[[2]]])));#
		return(list(mmRow,mumatRow));#
	}#
	ret <- lapply(1:length(ephy$eventBranchSegs), function(y) bySample(y, ephy));#
	mm <- lapply(ret, function(x) x[[1]]);#
	mm <- do.call(rbind, mm);#
	mumat <- lapply(ret, function(x) x[[2]]);#
	mumat <- do.call(rbind, mumat);#
	obj <- list();#
	if (ephy$type == 'diversification') {#
		obj$lambda <- mm;#
		obj$mu <- mumat;#
	}#
	if (ephy$type == 'trait') {#
		obj$beta <- mm;#
	}#
	obj$times <- tvec;#
	class(obj) <- 'bamm-ratematrix';#
	if (ephy$type=='diversification') {#
		obj$type = 'diversification';#
	} else {#
		obj$type = 'trait';	#
	}#
	return(obj);#
}
getRateThroughTimeMatrix2(ephy)->new
head(new$lambda)
all.equal(old$lambda,new$lambda)
##############################################################
##
#	getRateThroughTimeMatrix(....)#
#	#
#	include or exclude options:#
#	start.time		=	 start time (in units before present)#
#						 if NULL, starts at root#
#	end.time		=	 end time #
#						 if NULL, ends at present#
#	nslices			=	 number of time cuts#
#	Return#
#	list with components:#
#					$times	= the time vector#
#					$lambda = speciation rate matrix#
#					$mu 	= extinction rate matrix#
# 					$type   = diversification or trait (needs to be extended to trait data)		#
# returns object of class bamm-ratematrix#
#	 #
#
getRateThroughTimeMatrix2 <- function(ephy, start.time=NULL, end.time=NULL, nslices=100, node=NULL, nodetype = 'include') {#
	if (!'bammdata' %in% class(ephy)) {#
		stop("Object ephy must be of class 'bammdata'\n");#
	}#
	if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}#
	bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);#
#
	if (is.null(start.time)) {#
		start.time <- max(bt);#
	}#
	if (is.null(end.time)) {#
		end.time <- 0;#
	}#
	tvec <- seq(start.time, end.time, length.out = nslices);#
	#tol = 1*10^-decimals(ephy$eventBranchSegs[[1]][1,2]);#
	tol <- 0.00001#
	goodTime <- function (vec, val, tol) {#
		(vec[,2] - val <= tol) & (val - vec[,3] <= tol);#
	}#
	getRates <- function(time, es, events, isGoodNode) {#
		isGoodTime <- goodTime(es, time, tol=tol);#
		if (!(is.null(node))) { # only enter this if not the root. otherwise, only have to set once per i.#
			isGoodNode <- es[,1] %in% nodeset;	#
		}#
		estemp <- es[isGoodTime & isGoodNode, ];#
		if (is.vector(estemp)) {#
			index <- estemp[4];#
		} else {#
			index <- estemp[,4];#
		}#
		tvv <- time - events$time[index];#
		rates <- exponentialRate(tvv, events$lam1[index], events$lam2[index]);#
		return(list(rates,index));#
	}#
#
	bySample <- function(counter, ephy) {#
		es <- ephy$eventBranchSegs[[counter]];#
		events <- ephy$eventData[[counter]];#
		isGoodNode <- rep(TRUE, nrow(es));#
		ret <- lapply(tvec, function(x) getRates(time = x, es, events, isGoodNode));#
		mmRow <- unlist(lapply(ret, function(x) mean(x[[1]])));#
		mumatRow <- unlist(lapply(ret, function(x) mean(events$mu1[x[[2]]])));#
		return(list(mmRow,mumatRow));#
	}#
	ret <- lapply(1:length(ephy$eventBranchSegs), function(y) bySample(y, ephy));#
	mm <- lapply(ret, function(x) x[[1]]);#
	mm <- do.call(rbind, mm);#
	mumat <- lapply(ret, function(x) x[[2]]);#
	mumat <- do.call(rbind, mumat);#
	obj <- list();#
	if (ephy$type == 'diversification') {#
		obj$lambda <- mm;#
		obj$mu <- mumat;#
	}#
	if (ephy$type == 'trait') {#
		obj$beta <- mm;#
	}#
	obj$times <- tvec;#
	class(obj) <- 'bamm-ratematrix';#
	if (ephy$type=='diversification') {#
		obj$type = 'diversification';#
	} else {#
		obj$type = 'trait';	#
	}#
	return(obj);#
}
getRateThroughTimeMatrix2(ephy)->new
all.equal(old$lambda,new$lambda)
head(old$lambda)
getRateThroughTimeMatrix(ephy,nslices=10)->old
getRateThroughTimeMatrix2(ephy,nslices=10) ->new
head(old$lambda)
head(new$lambda)
tvec
events
##############################################################
##
#	getRateThroughTimeMatrix(....)#
#	#
#	include or exclude options:#
#	start.time		=	 start time (in units before present)#
#						 if NULL, starts at root#
#	end.time		=	 end time #
#						 if NULL, ends at present#
#	nslices			=	 number of time cuts#
#	Return#
#	list with components:#
#					$times	= the time vector#
#					$lambda = speciation rate matrix#
#					$mu 	= extinction rate matrix#
# 					$type   = diversification or trait (needs to be extended to trait data)		#
# returns object of class bamm-ratematrix#
#	 #
#
getRateThroughTimeMatrix2 <- function(ephy, start.time=NULL, end.time=NULL, nslices=100, node=NULL, nodetype = 'include') {#
	if (!'bammdata' %in% class(ephy)) {#
		stop("Object ephy must be of class 'bammdata'\n");#
	}#
	if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}#
	bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);#
#
	#convert from time before present to node heights#
	if (!is.null(start.time)) {#
		start.time <- max(bt) - start.time;#
	}#
	if (!is.null(end.time)) {#
		end.time <- max(bt) - end.time;#
	}#
#
	if (is.null(start.time)) {#
		start.time <- max(bt) - maxpossible;#
	}#
	if (is.null(end.time)) {#
		end.time <- max(bt);#
	}#
	tvec <- seq(start.time, end.time, length.out= nslices);#
	#tol = 1*10^-decimals(ephy$eventBranchSegs[[1]][1,2]);#
	tol <- 0.00001#
	goodTime <- function (vec, val, tol) {#
		(vec[,2] - val <= tol) & (val - vec[,3] <= tol);#
	}#
	getRates <- function(time, es, events, isGoodNode) {#
		isGoodTime <- goodTime(es, time, tol=tol);#
		if (!(is.null(node))) { # only enter this if not the root. otherwise, only have to set once per i.#
			isGoodNode <- es[,1] %in% nodeset;	#
		}#
		estemp <- es[isGoodTime & isGoodNode, ];#
		if (is.vector(estemp)) {#
			index <- estemp[4];#
		} else {#
			index <- estemp[,4];#
		}#
		tvv <- time - events$time[index];#
		rates <- exponentialRate(tvv, events$lam1[index], events$lam2[index]);#
		return(list(rates,index));#
	}#
#
	bySample <- function(counter, ephy) {#
		es <- ephy$eventBranchSegs[[counter]];#
		events <- ephy$eventData[[counter]];#
		isGoodNode <- rep(TRUE, nrow(es));#
		ret <- lapply(tvec, function(x) getRates(time = x, es, events, isGoodNode));#
		mmRow <- unlist(lapply(ret, function(x) mean(x[[1]])));#
		mumatRow <- unlist(lapply(ret, function(x) mean(events$mu1[x[[2]]])));#
		return(list(mmRow,mumatRow));#
	}#
	ret <- lapply(1:length(ephy$eventBranchSegs), function(y) bySample(y, ephy));#
	mm <- lapply(ret, function(x) x[[1]]);#
	mm <- do.call(rbind, mm);#
	mumat <- lapply(ret, function(x) x[[2]]);#
	mumat <- do.call(rbind, mumat);#
	obj <- list();#
	if (ephy$type == 'diversification') {#
		obj$lambda <- mm;#
		obj$mu <- mumat;#
	}#
	if (ephy$type == 'trait') {#
		obj$beta <- mm;#
	}#
	obj$times <- tvec;#
	class(obj) <- 'bamm-ratematrix';#
	if (ephy$type=='diversification') {#
		obj$type = 'diversification';#
	} else {#
		obj$type = 'trait';	#
	}#
	return(obj);#
}
getRateThroughTimeMatrix2(ephy,nslices=10)->old
all.equal(old$lambda,new$lambda)
start.time=NULL
end.time=NULL
nslices=100
node=NULL
nodetype = 'include'
if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}
bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);
start.time
##############################################################
##
#	getRateThroughTimeMatrix(....)#
#	#
#	include or exclude options:#
#	start.time		=	 start time (in units before present)#
#						 if NULL, starts at root#
#	end.time		=	 end time #
#						 if NULL, ends at present#
#	nslices			=	 number of time cuts#
#	Return#
#	list with components:#
#					$times	= the time vector#
#					$lambda = speciation rate matrix#
#					$mu 	= extinction rate matrix#
# 					$type   = diversification or trait (needs to be extended to trait data)		#
# returns object of class bamm-ratematrix#
#	 #
#
getRateThroughTimeMatrix2 <- function(ephy, start.time=NULL, end.time=NULL, nslices=100, node=NULL, nodetype = 'include') {#
	if (!'bammdata' %in% class(ephy)) {#
		stop("Object ephy must be of class 'bammdata'\n");#
	}#
	if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}#
	bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);#
	if (is.null(start.time)) {#
		start.time <- max(bt) - maxpossible;#
	}#
	if (is.null(end.time)) {#
		end.time <- max(bt);#
	}#
	#convert from time before present to node heights#
	if (!is.null(start.time)) {#
		start.time <- max(bt) - start.time;#
	}#
	if (!is.null(end.time)) {#
		end.time <- max(bt) - end.time;#
	}#
	tvec <- seq(start.time, end.time, length.out= nslices);#
	#tol = 1*10^-decimals(ephy$eventBranchSegs[[1]][1,2]);#
	tol <- 0.00001#
	goodTime <- function (vec, val, tol) {#
		(vec[,2] - val <= tol) & (val - vec[,3] <= tol);#
	}#
	getRates <- function(time, es, events, isGoodNode) {#
		isGoodTime <- goodTime(es, time, tol=tol);#
		if (!(is.null(node))) { # only enter this if not the root. otherwise, only have to set once per i.#
			isGoodNode <- es[,1] %in% nodeset;	#
		}#
		estemp <- es[isGoodTime & isGoodNode, ];#
		if (is.vector(estemp)) {#
			index <- estemp[4];#
		} else {#
			index <- estemp[,4];#
		}#
		tvv <- time - events$time[index];#
		rates <- exponentialRate(tvv, events$lam1[index], events$lam2[index]);#
		return(list(rates,index));#
	}#
#
	bySample <- function(counter, ephy) {#
		es <- ephy$eventBranchSegs[[counter]];#
		events <- ephy$eventData[[counter]];#
		isGoodNode <- rep(TRUE, nrow(es));#
		ret <- lapply(tvec, function(x) getRates(time = x, es, events, isGoodNode));#
		mmRow <- unlist(lapply(ret, function(x) mean(x[[1]])));#
		mumatRow <- unlist(lapply(ret, function(x) mean(events$mu1[x[[2]]])));#
		return(list(mmRow,mumatRow));#
	}#
	ret <- lapply(1:length(ephy$eventBranchSegs), function(y) bySample(y, ephy));#
	mm <- lapply(ret, function(x) x[[1]]);#
	mm <- do.call(rbind, mm);#
	mumat <- lapply(ret, function(x) x[[2]]);#
	mumat <- do.call(rbind, mumat);#
	obj <- list();#
	if (ephy$type == 'diversification') {#
		obj$lambda <- mm;#
		obj$mu <- mumat;#
	}#
	if (ephy$type == 'trait') {#
		obj$beta <- mm;#
	}#
	obj$times <- tvec;#
	class(obj) <- 'bamm-ratematrix';#
	if (ephy$type=='diversification') {#
		obj$type = 'diversification';#
	} else {#
		obj$type = 'trait';	#
	}#
	return(obj);#
}
getRateThroughTimeMatrix(ephy)->old
getRateThroughTimeMatrix2(ephy)->new
all.equal(old$lambda,new$lambda)
start.time=NULL
end.time=NULL
nslices
node
nodetype
if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}
bt <- branching.times(as.phylo.bammdata(ephy));
maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);
if (is.null(start.time)) {#
		start.time <- max(bt) - maxpossible;#
	}#
	if (is.null(end.time)) {#
		end.time <- max(bt);#
	}
start.time
end.time
start.time
end.time
##############################################################
##
#	getRateThroughTimeMatrix(....)#
#	#
#	include or exclude options:#
#	start.time		=	 start time (in units before present)#
#						 if NULL, starts at root#
#	end.time		=	 end time #
#						 if NULL, ends at present#
#	nslices			=	 number of time cuts#
#	Return#
#	list with components:#
#					$times	= the time vector#
#					$lambda = speciation rate matrix#
#					$mu 	= extinction rate matrix#
# 					$type   = diversification or trait (needs to be extended to trait data)		#
# returns object of class bamm-ratematrix#
#	 #
#
getRateThroughTimeMatrix2 <- function(ephy, start.time=NULL, end.time=NULL, nslices=100, node=NULL, nodetype = 'include') {#
	if (!'bammdata' %in% class(ephy)) {#
		stop("Object ephy must be of class 'bammdata'\n");#
	}#
	if (is.null(node)) {#
		nodeset <- c(length(ephy$tip.label)+1, ephy$edge[,2]);#
	} else if (!is.null(node) & nodetype == 'include') {#
		nodeset <- unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set))#
	} else if (!is.null(node) & nodetype == 'exclude') {#
		nodeset <- setdiff( ephy$edge[,2], unlist(sapply(node, function(x) getDesc(ephy, x)$desc_set)));#
		nodeset <- c(length(ephy$tip.label)+1, nodeset);#
	} else {#
		stop('error in getRateThroughTimeMatrix\n');#
	}#
	bt <- branching.times(as.phylo.bammdata(ephy));#
	maxpossible <- max(bt[as.character(intersect(nodeset, ephy$edge[,1]))]);#
	#convert from time before present to node heights#
	if (!is.null(start.time)) {#
		start.time <- max(bt) - start.time;#
	}#
	if (!is.null(end.time)) {#
		end.time <- max(bt) - end.time;#
	}#
	if (is.null(start.time)) {#
		start.time <- max(bt) - maxpossible;#
	}#
	if (is.null(end.time)) {#
		end.time <- max(bt);#
	}#
	tvec <- seq(start.time, end.time, length.out= nslices);#
	#tol = 1*10^-decimals(ephy$eventBranchSegs[[1]][1,2]);#
	tol <- 0.00001#
	goodTime <- function (vec, val, tol) {#
		(vec[,2] - val <= tol) & (val - vec[,3] <= tol);#
	}#
	getRates <- function(time, es, events, isGoodNode) {#
		isGoodTime <- goodTime(es, time, tol=tol);#
		if (!(is.null(node))) { # only enter this if not the root. otherwise, only have to set once per i.#
			isGoodNode <- es[,1] %in% nodeset;	#
		}#
		estemp <- es[isGoodTime & isGoodNode, ];#
		if (is.vector(estemp)) {#
			index <- estemp[4];#
		} else {#
			index <- estemp[,4];#
		}#
		tvv <- time - events$time[index];#
		rates <- exponentialRate(tvv, events$lam1[index], events$lam2[index]);#
		return(list(rates,index));#
	}#
#
	bySample <- function(counter, ephy) {#
		es <- ephy$eventBranchSegs[[counter]];#
		events <- ephy$eventData[[counter]];#
		isGoodNode <- rep(TRUE, nrow(es));#
		ret <- lapply(tvec, function(x) getRates(time = x, es, events, isGoodNode));#
		mmRow <- unlist(lapply(ret, function(x) mean(x[[1]])));#
		mumatRow <- unlist(lapply(ret, function(x) mean(events$mu1[x[[2]]])));#
		return(list(mmRow,mumatRow));#
	}#
	ret <- lapply(1:length(ephy$eventBranchSegs), function(y) bySample(y, ephy));#
	mm <- lapply(ret, function(x) x[[1]]);#
	mm <- do.call(rbind, mm);#
	mumat <- lapply(ret, function(x) x[[2]]);#
	mumat <- do.call(rbind, mumat);#
	obj <- list();#
	if (ephy$type == 'diversification') {#
		obj$lambda <- mm;#
		obj$mu <- mumat;#
	}#
	if (ephy$type == 'trait') {#
		obj$beta <- mm;#
	}#
	obj$times <- tvec;#
	class(obj) <- 'bamm-ratematrix';#
	if (ephy$type=='diversification') {#
		obj$type = 'diversification';#
	} else {#
		obj$type = 'trait';	#
	}#
	return(obj);#
}
getRateThroughTimeMatrix(ephy)->old
getRateThroughTimeMatrix2(ephy)->new
all.equal(old$lambda,new$lambda)
plotRateThroughTime(ephy)
plotRateThroughTime
##############################################################
##
#	plotRateThroughTime <- function(...)#
##
#	ephy = object of class 'bammdata' or 'bamm-ratematrix'#
#		if bamm-ratematrix, start.time, end.time, node, nslices, nodetype are not used.#
#	useMedian = boolean, will plot median if TRUE, mean if FALSE.#
#	intervals if NULL, no intervals will be plotted, otherwise a vector of quantiles must be supplied (these will define shaded polygons)#
#	ratetype = autodetects diversification vs traits (based on input object 'type'), if 'auto', defaults to speciation (for diversification) or beta (for traits). Can alternatively specify 'netdiv' or 'extinction'. #
#	nBins = number of time slices used to generate rates through time#
#	smooth = boolean whether or not to apply loess smoothing#
#	smoothParam = loess smoothing parameter, ignored if smooth = F#
#	opacity = opacity of color for interval polygons#
#	intervalCol = transparent color for interval polygons#
#	avgCol = color for mean/median line#
#	start.time = start time to be fed to getRateThroughTimeMatrix#
#	end.time = end time to be fed to getRateThroughTimeMatrix#
#	node = if supplied, the clade descended from this node will be used.#
#	nodetype = supplied to getRateThroughTimeMatrix#
#	plot = boolean: if TRUE, a plot will be returned, if FALSE, the data for the plot will be returned. #
#	xticks = number of ticks on the x-axis.#
#	yticks = number of ticks on the y-axis.#
#	xlim = vector of length 2 with min and max times for x axis. X axis is time since present, so if plotting till the present, xlim[2]==0. Can also be 'auto'.#
#	ylim = vector of length 2 with min and max rates for y axis. Can also be 'auto'. #
#	add = boolean: should rates be added to an existing plot#
##
#	+ several undocumented args to set plot parameters: mar, cex, xline, yline, etc.#
#	#
#
plotRateThroughTime <- function(ephy, useMedian = TRUE, intervals=seq(from = 0,to = 1,by = 0.01), ratetype = 'auto', nBins = 100, smooth = FALSE, smoothParam = 0.20, opacity = 0.01, intervalCol='blue', avgCol='red',start.time = NULL, end.time = NULL, node = NULL, nodetype='include', plot = TRUE, cex.axis=1, cex.lab=1.3, lwd=3, xline=3.5, yline=3.5, mar=c(6,6,1,1), xticks=5, yticks=5, xlim='auto', ylim='auto',add=FALSE, axis.labels=TRUE) {#
	if (!any(c('bammdata', 'bamm-ratematrix') %in% class(ephy))) {#
		stop("ERROR: Object ephy must be of class 'bammdata' or 'bamm-ratematrix'.\n");#
	}#
	if (!is.logical(useMedian)) {#
		stop('ERROR: useMedian must be either TRUE or FALSE.');#
	}#
	if (!any(c('numeric', 'NULL') %in% class(intervals))) {#
		stop("ERROR: intervals must be either 'NULL' or a vector of quantiles.");#
	}#
	if (!is.logical(smooth)) {#
		stop('ERROR: smooth must be either TRUE or FALSE.');#
	}#
	if ('bammdata' %in% class(ephy)) {#
		#get rates through binned time#
		rmat <- getRateThroughTimeMatrix2(ephy, start.time = start.time, end.time = end.time, node = node, nslices = nBins, nodetype=nodetype);#
	}#
	if ('bamm-ratematrix' %in% class(ephy)) {#
		if (!any(is.null(c(start.time, end.time, node)))) {#
			stop('ERROR: You cannot specify start.time, end.time or node if the rate matrix is being provided. Please either provide the bammdata object instead or specify start.time, end.time or node in the creation of the bamm-ratematrix.')#
		}#
		#use existing rate matrix#
		rmat <- ephy;#
	}#
#
	#set appropriate rates#
	if (ratetype == 'speciation') {#
		ratetype <- 'auto';#
	}#
	if (ratetype != 'auto' & ratetype != 'extinction' & ratetype != 'netdiv') {#
		stop("ERROR: ratetype must be 'auto', 'extinction', or 'netdiv'.\n");#
	}#
	if (ephy$type == 'trait' & ratetype != 'auto') {#
		stop("ERROR: If input object is of type 'trait', ratetype can only be 'auto'.")#
	}#
	if (ratetype == 'auto' & ephy$type == 'diversification') {#
		rate <- rmat$lambda;#
		ratelabel <- 'speciation rate';#
	}#
	if (ratetype == 'auto' & ephy$type == 'trait') {#
		rate <- rmat$beta;#
		ratelabel <- 'trait rate';#
	}#
	if (ratetype == 'extinction') {#
		rate <- rmat$mu;#
		ratelabel <- 'extinction rate';#
	}#
	if (ratetype == 'netdiv') {#
		rate <- rmat$lambda - rmat$mu;#
		ratelabel <- 'net diversification rate';#
	}#
#
	#generate coordinates for polygons#
	rmat$times <- max(rmat$times) - rmat$times;#
	maxTime <- max(rmat$times)#
	if (!is.null(intervals)) {#
		mm <- apply(rate, MARGIN = 2, quantile, intervals);#
#
		poly <- list();#
		q1 <- 1;#
		q2 <- nrow(mm);#
		repeat {#
			if (q1 >= q2) {break}#
			a <- as.data.frame(cbind(rmat$times,mm[q1,]));#
			b <- as.data.frame(cbind(rmat$times,mm[q2,]));#
			b <- b[rev(rownames(b)),];#
			colnames(a) <- colnames(b) <- c('x','y');#
			poly[[q1]] <- rbind(a,b);#
			q1 <- q1 + 1;#
			q2 <- q2 - 1;#
		}#
	}#
#
	#Calculate averaged data line#
	if (!useMedian) {#
		avg <- colMeans(rate);#
	} else {#
		avg <- unlist(apply(rate,2,median));#
	}#
	#apply loess smoothing to intervals#
	if (smooth) {#
		for (i in 1:length(poly)) {#
			p <- poly[[i]];#
			rows <- nrow(p);#
			p[1:rows/2,2] <- loess(p[1:rows/2,2] ~ p[1:rows/2,1],span = smoothParam)$fitted;#
			p[(rows/2):rows,2] <- loess(p[(rows/2):rows,2] ~ p[(rows/2):rows,1],span = smoothParam)$fitted;#
			poly[[i]] <- p;#
		}#
		avg <- loess(avg ~ rmat$time,span = smoothParam)$fitted;#
	}#
#
	#begin plotting#
	if (plot) {#
		if (!add) {#
			plot.new();#
			par(mar=mar);#
			if (unique(xlim == 'auto') & unique(ylim == 'auto')) {#
				xMin <- maxTime;#
				xMax <- 0;#
				yMin <- 0;#
				if (!is.null(intervals)){#
					yMax <- max(poly[[1]][,2]);#
				} else {#
					yMax <- max(avg);#
				}#
			}#
			if (unique(xlim != 'auto') & unique(ylim == 'auto')) {#
				xMin <- xlim[1];#
				xMax <- xlim[2];#
				yMin <- 0;#
				if (!is.null(intervals)){#
					yMax <- max(poly[[1]][,2]);#
				} else {#
					yMax <- max(avg);#
				}#
			}#
			if (unique(xlim == 'auto') & unique(ylim != 'auto')) {#
				xMin <- maxTime;#
				xMax <- 0;#
				yMin <- ylim[1];#
				yMax <- ylim[2];#
			}#
			if (unique(xlim != 'auto') & unique(ylim != 'auto')) {#
				xMin <- xlim[1];#
				xMax <- xlim[2];#
				yMin <- ylim[1];#
				yMax <- ylim[2];#
			}#
			plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));#
			axis(at=c(1.3*xMin,seq(xMin,xMax, length.out=xticks+1)), labels = c(1.3*xMin,signif(seq(xMin, xMax, length.out=xticks+1),digits=2)), cex.axis = cex.axis, side = 1);#
			axis(at=c(-0.2,seq(yMin, 1.2*yMax, length.out=yticks+1)), labels = c(-0.2,signif(seq(yMin, 1.2*yMax, length.out=yticks+1),digits=2)), las=1, cex.axis = cex.axis, side = 2);#
			if (axis.labels) {#
				mtext(side = 1, text = 'time before present', line = xline, cex = cex.lab);#
				mtext(side = 2, text = ratelabel, line = yline, cex = cex.lab);#
			}#
		}#
		#plot intervals#
		if (!is.null(intervals)) {#
			for (i in 1:length(poly)) {#
				polygon(x=poly[[i]][,1],y=poly[[i]][,2],col=transparentColor(intervalCol,opacity),border=NA);#
			}#
		}#
		lines(x = rmat$time, y = avg, lwd = lwd, col = avgCol);#
	} else {#
		return(list(poly = poly,avg = avg,times = rmat$time));#
	}#
}
##############################################################
##
#	plotRateThroughTime <- function(...)#
##
#	ephy = object of class 'bammdata' or 'bamm-ratematrix'#
#		if bamm-ratematrix, start.time, end.time, node, nslices, nodetype are not used.#
#	useMedian = boolean, will plot median if TRUE, mean if FALSE.#
#	intervals if NULL, no intervals will be plotted, otherwise a vector of quantiles must be supplied (these will define shaded polygons)#
#	ratetype = autodetects diversification vs traits (based on input object 'type'), if 'auto', defaults to speciation (for diversification) or beta (for traits). Can alternatively specify 'netdiv' or 'extinction'. #
#	nBins = number of time slices used to generate rates through time#
#	smooth = boolean whether or not to apply loess smoothing#
#	smoothParam = loess smoothing parameter, ignored if smooth = F#
#	opacity = opacity of color for interval polygons#
#	intervalCol = transparent color for interval polygons#
#	avgCol = color for mean/median line#
#	start.time = start time to be fed to getRateThroughTimeMatrix#
#	end.time = end time to be fed to getRateThroughTimeMatrix#
#	node = if supplied, the clade descended from this node will be used.#
#	nodetype = supplied to getRateThroughTimeMatrix#
#	plot = boolean: if TRUE, a plot will be returned, if FALSE, the data for the plot will be returned. #
#	xticks = number of ticks on the x-axis.#
#	yticks = number of ticks on the y-axis.#
#	xlim = vector of length 2 with min and max times for x axis. X axis is time since present, so if plotting till the present, xlim[2]==0. Can also be 'auto'.#
#	ylim = vector of length 2 with min and max rates for y axis. Can also be 'auto'. #
#	add = boolean: should rates be added to an existing plot#
##
#	+ several undocumented args to set plot parameters: mar, cex, xline, yline, etc.#
#	#
#
plotRateThroughTime2 <- function(ephy, useMedian = TRUE, intervals=seq(from = 0,to = 1,by = 0.01), ratetype = 'auto', nBins = 100, smooth = FALSE, smoothParam = 0.20, opacity = 0.01, intervalCol='blue', avgCol='red',start.time = NULL, end.time = NULL, node = NULL, nodetype='include', plot = TRUE, cex.axis=1, cex.lab=1.3, lwd=3, xline=3.5, yline=3.5, mar=c(6,6,1,1), xticks=5, yticks=5, xlim='auto', ylim='auto',add=FALSE, axis.labels=TRUE) {#
	if (!any(c('bammdata', 'bamm-ratematrix') %in% class(ephy))) {#
		stop("ERROR: Object ephy must be of class 'bammdata' or 'bamm-ratematrix'.\n");#
	}#
	if (!is.logical(useMedian)) {#
		stop('ERROR: useMedian must be either TRUE or FALSE.');#
	}#
	if (!any(c('numeric', 'NULL') %in% class(intervals))) {#
		stop("ERROR: intervals must be either 'NULL' or a vector of quantiles.");#
	}#
	if (!is.logical(smooth)) {#
		stop('ERROR: smooth must be either TRUE or FALSE.');#
	}#
	if ('bammdata' %in% class(ephy)) {#
		#get rates through binned time#
		rmat <- getRateThroughTimeMatrix2(ephy, start.time = start.time, end.time = end.time, node = node, nslices = nBins, nodetype=nodetype);#
	}#
	if ('bamm-ratematrix' %in% class(ephy)) {#
		if (!any(is.null(c(start.time, end.time, node)))) {#
			stop('ERROR: You cannot specify start.time, end.time or node if the rate matrix is being provided. Please either provide the bammdata object instead or specify start.time, end.time or node in the creation of the bamm-ratematrix.')#
		}#
		#use existing rate matrix#
		rmat <- ephy;#
	}#
#
	#set appropriate rates#
	if (ratetype == 'speciation') {#
		ratetype <- 'auto';#
	}#
	if (ratetype != 'auto' & ratetype != 'extinction' & ratetype != 'netdiv') {#
		stop("ERROR: ratetype must be 'auto', 'extinction', or 'netdiv'.\n");#
	}#
	if (ephy$type == 'trait' & ratetype != 'auto') {#
		stop("ERROR: If input object is of type 'trait', ratetype can only be 'auto'.")#
	}#
	if (ratetype == 'auto' & ephy$type == 'diversification') {#
		rate <- rmat$lambda;#
		ratelabel <- 'speciation rate';#
	}#
	if (ratetype == 'auto' & ephy$type == 'trait') {#
		rate <- rmat$beta;#
		ratelabel <- 'trait rate';#
	}#
	if (ratetype == 'extinction') {#
		rate <- rmat$mu;#
		ratelabel <- 'extinction rate';#
	}#
	if (ratetype == 'netdiv') {#
		rate <- rmat$lambda - rmat$mu;#
		ratelabel <- 'net diversification rate';#
	}#
#
	#generate coordinates for polygons#
	rmat$times <- max(rmat$times) - rmat$times;#
	maxTime <- max(rmat$times)#
	if (!is.null(intervals)) {#
		mm <- apply(rate, MARGIN = 2, quantile, intervals);#
#
		poly <- list();#
		q1 <- 1;#
		q2 <- nrow(mm);#
		repeat {#
			if (q1 >= q2) {break}#
			a <- as.data.frame(cbind(rmat$times,mm[q1,]));#
			b <- as.data.frame(cbind(rmat$times,mm[q2,]));#
			b <- b[rev(rownames(b)),];#
			colnames(a) <- colnames(b) <- c('x','y');#
			poly[[q1]] <- rbind(a,b);#
			q1 <- q1 + 1;#
			q2 <- q2 - 1;#
		}#
	}#
#
	#Calculate averaged data line#
	if (!useMedian) {#
		avg <- colMeans(rate);#
	} else {#
		avg <- unlist(apply(rate,2,median));#
	}#
	#apply loess smoothing to intervals#
	if (smooth) {#
		for (i in 1:length(poly)) {#
			p <- poly[[i]];#
			rows <- nrow(p);#
			p[1:rows/2,2] <- loess(p[1:rows/2,2] ~ p[1:rows/2,1],span = smoothParam)$fitted;#
			p[(rows/2):rows,2] <- loess(p[(rows/2):rows,2] ~ p[(rows/2):rows,1],span = smoothParam)$fitted;#
			poly[[i]] <- p;#
		}#
		avg <- loess(avg ~ rmat$time,span = smoothParam)$fitted;#
	}#
#
	#begin plotting#
	if (plot) {#
		if (!add) {#
			plot.new();#
			par(mar=mar);#
			if (unique(xlim == 'auto') & unique(ylim == 'auto')) {#
				xMin <- maxTime;#
				xMax <- 0;#
				yMin <- 0;#
				if (!is.null(intervals)){#
					yMax <- max(poly[[1]][,2]);#
				} else {#
					yMax <- max(avg);#
				}#
			}#
			if (unique(xlim != 'auto') & unique(ylim == 'auto')) {#
				xMin <- xlim[1];#
				xMax <- xlim[2];#
				yMin <- 0;#
				if (!is.null(intervals)){#
					yMax <- max(poly[[1]][,2]);#
				} else {#
					yMax <- max(avg);#
				}#
			}#
			if (unique(xlim == 'auto') & unique(ylim != 'auto')) {#
				xMin <- maxTime;#
				xMax <- 0;#
				yMin <- ylim[1];#
				yMax <- ylim[2];#
			}#
			if (unique(xlim != 'auto') & unique(ylim != 'auto')) {#
				xMin <- xlim[1];#
				xMax <- xlim[2];#
				yMin <- ylim[1];#
				yMax <- ylim[2];#
			}#
			plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));#
			axis(at=c(1.3*xMin,seq(xMin,xMax, length.out=xticks+1)), labels = c(1.3*xMin,signif(seq(xMin, xMax, length.out=xticks+1),digits=2)), cex.axis = cex.axis, side = 1);#
			axis(at=c(-0.2,seq(yMin, 1.2*yMax, length.out=yticks+1)), labels = c(-0.2,signif(seq(yMin, 1.2*yMax, length.out=yticks+1),digits=2)), las=1, cex.axis = cex.axis, side = 2);#
			if (axis.labels) {#
				mtext(side = 1, text = 'time before present', line = xline, cex = cex.lab);#
				mtext(side = 2, text = ratelabel, line = yline, cex = cex.lab);#
			}#
		}#
		#plot intervals#
		if (!is.null(intervals)) {#
			for (i in 1:length(poly)) {#
				polygon(x=poly[[i]][,1],y=poly[[i]][,2],col=transparentColor(intervalCol,opacity),border=NA);#
			}#
		}#
		lines(x = rmat$time, y = avg, lwd = lwd, col = avgCol);#
	} else {#
		return(list(poly = poly,avg = avg,times = rmat$time));#
	}#
}
require(BAMMtools)#
data(events.whales)#
data(whales)#
ephy <- getEventData(whales,events.whales)
?plotRateThroughTime
plotRateThroughTime(ephy)
plotRateThroughTime(ephy,ylim=c(0,2))
seq(0,2,6)
seq(0,2,length.out=6)
signif(seq(0,2,length.out=6),digits=2
)
1.8/6
2.0/6
plot
2/0.4
yticks=5
2/yticks
1.8/yticks
useMedian = TRUE
intervals=seq(from = 0,to = 1,by = 0.01)
ratetype = 'auto'
nBins = 100
smooth = FALSE
smoothParam = 0.20
opacity = 0.01
intervalCol='blue'
avgCol='red'
start.time = NULL
end.time = NULL
node = NULL
nodetype='include'
cex.axis=1
cex.lab=1.3
lwd=3
xline=3.5
yline=3.5
xticks=5
xlim='auto'
ylim='auto'
axis.labels=TRUE
if ('bammdata' %in% class(ephy)) {#
		#get rates through binned time#
		rmat <- getRateThroughTimeMatrix(ephy, start.time = start.time, end.time = end.time, node = node, nslices = nBins, nodetype=nodetype);#
	}#
	if ('bamm-ratematrix' %in% class(ephy)) {#
		if (!any(is.null(c(start.time, end.time, node)))) {#
			stop('ERROR: You cannot specify start.time, end.time or node if the rate matrix is being provided. Please either provide the bammdata object instead or specify start.time, end.time or node in the creation of the bamm-ratematrix.')#
		}#
		#use existing rate matrix#
		rmat <- ephy;#
	}
#set appropriate rates#
	if (ratetype == 'speciation') {#
		ratetype <- 'auto';#
	}#
	if (ratetype != 'auto' & ratetype != 'extinction' & ratetype != 'netdiv') {#
		stop("ERROR: ratetype must be 'auto', 'extinction', or 'netdiv'.\n");#
	}#
	if (ephy$type == 'trait' & ratetype != 'auto') {#
		stop("ERROR: If input object is of type 'trait', ratetype can only be 'auto'.")#
	}#
	if (ratetype == 'auto' & ephy$type == 'diversification') {#
		rate <- rmat$lambda;#
		ratelabel <- 'speciation rate';#
	}#
	if (ratetype == 'auto' & ephy$type == 'trait') {#
		rate <- rmat$beta;#
		ratelabel <- 'trait rate';#
	}#
	if (ratetype == 'extinction') {#
		rate <- rmat$mu;#
		ratelabel <- 'extinction rate';#
	}#
	if (ratetype == 'netdiv') {#
		rate <- rmat$lambda - rmat$mu;#
		ratelabel <- 'net diversification rate';#
	}#
#
	maxTime <- max(rmat$times)
#remove NaN columns#
	nanCol <- apply(rate, 2, function(x) any(is.nan(x)));#
	rate <- rate[,which(nanCol == FALSE)];#
	rmat$times <- rmat$times[which(nanCol == FALSE)];#
#
	#generate coordinates for polygons#
	rmat$times <- max(rmat$times) - rmat$times;#
	if (!is.null(intervals)) {#
		mm <- apply(rate, MARGIN = 2, quantile, intervals);#
#
		poly <- list();#
		q1 <- 1;#
		q2 <- nrow(mm);#
		repeat {#
			if (q1 >= q2) {break}#
			a <- as.data.frame(cbind(rmat$times,mm[q1,]));#
			b <- as.data.frame(cbind(rmat$times,mm[q2,]));#
			b <- b[rev(rownames(b)),];#
			colnames(a) <- colnames(b) <- c('x','y');#
			poly[[q1]] <- rbind(a,b);#
			q1 <- q1 + 1;#
			q2 <- q2 - 1;#
		}#
	}
#Calculate averaged data line#
	if (!useMedian) {#
		avg <- colMeans(rate);#
	} else {#
		avg <- unlist(apply(rate,2,median));#
	}#
	#apply loess smoothing to intervals#
	if (smooth) {#
		for (i in 1:length(poly)) {#
			p <- poly[[i]];#
			rows <- nrow(p);#
			p[1:rows/2,2] <- loess(p[1:rows/2,2] ~ p[1:rows/2,1],span = smoothParam)$fitted;#
			p[(rows/2):rows,2] <- loess(p[(rows/2):rows,2] ~ p[(rows/2):rows,1],span = smoothParam)$fitted;#
			poly[[i]] <- p;#
		}#
		avg <- loess(avg ~ rmat$time,span = smoothParam)$fitted;#
	}
if (unique(xlim == 'auto') & unique(ylim == 'auto')) {#
				xMin <- maxTime;#
				xMax <- 0;#
				yMin <- 0;#
				if (!is.null(intervals)){#
					yMax <- max(poly[[1]][,2]);#
				} else {#
					yMax <- max(avg);#
				}#
			}
plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));
axis(1)
plot.new();
plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));
axis(1)
axis(2)
?pretty
axTicks(1)
axTicks(2)
?par
par(bty=)
par(bty='l')
lines(x = rmat$time, y = avg, lwd = lwd, col = avgCol);
plot.new();
plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax),bty='l');
lines(x = rmat$time, y = avg, lwd = lwd, col = avgCol);
plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));
plot.new();
plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));
par(bty='L')
plot(x = rmat$time, y = avg, lwd = lwd, col = avgCol);
plot(x = rmat$time, y = avg, lwd = lwd, col = avgCol,type='l');
?pretty
pretty(2)
pretty(0:2)
pretty(0:2,n=5)
pretty(0:2,n=6)
pretty(0:2,n=7)
pretty(0:2,n=10)
pretty(0:2,n=3)
pretty(0:2,n=2)
pretty(0:2,h=2)
pretty(0:2,h=2,n=5)
axisTicks
?axisTicks()
axisTicks(c(0,2))
?axisTicks()
axisTicks(c(0,2),log=F)
axisTicks(c(0,2),log=F,nint=6)
axisTicks(c(0,2),log=F,nint=7)
yMac
yMax
axisTicks(c(0,yMax),log=F)
plot.new();
plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));
axis(at=axisTicks(c(xMin,xMax)), cex.axis = cex.axis, side = 1);
axis(at=axisTicks(c(xMin,xMax),log=FALSE), cex.axis = cex.axis, side = 1);
plot.new();
plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));
axis(at=axisTicks(c(xMin,xMax),log=FALSE), cex.axis = cex.axis, side = 1);
xMin
axis(at=axisTicks(c(1.2*xMin,xMax),log=FALSE), cex.axis = cex.axis, side = 1);
c(-0.2,axisTicks(c(yMin,yMax),log=FALSE))
axis(at=c(-0.2,axisTicks(c(yMin,yMax),log=FALSE)), las=1, cex.axis = cex.axis, side = 2);
axis(at=c(-0.2,axisTicks(c(yMin,yMax),log=FALSE,nint=3)), las=1, cex.axis = cex.axis, side = 2);
c(-0.2,axisTicks(c(yMin,yMax),log=FALSE,nint=3))
c(-0.2,axisTicks(c(yMin,yMax),log=FALSE))
yticks
plot.new();
if (unique(xlim == 'auto') & unique(ylim == 'auto')) {#
				xMin <- maxTime;#
				xMax <- 0;#
				yMin <- 0;#
				if (!is.null(intervals)){#
					yMax <- max(poly[[1]][,2]);#
				} else {#
					yMax <- max(avg);#
				}#
			}#
			if (unique(xlim != 'auto') & unique(ylim == 'auto')) {#
				xMin <- xlim[1];#
				xMax <- xlim[2];#
				yMin <- 0;#
				if (!is.null(intervals)){#
					yMax <- max(poly[[1]][,2]);#
				} else {#
					yMax <- max(avg);#
				}#
			}#
			if (unique(xlim == 'auto') & unique(ylim != 'auto')) {#
				xMin <- maxTime;#
				xMax <- 0;#
				yMin <- ylim[1];#
				yMax <- ylim[2];#
			}#
			if (unique(xlim != 'auto') & unique(ylim != 'auto')) {#
				xMin <- xlim[1];#
				xMax <- xlim[2];#
				yMin <- ylim[1];#
				yMax <- ylim[2];#
			}#
			plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));
axis(at=axisTicks(c(1.2*xMin,xMax),log=FALSE,nint=xticks), cex.axis = cex.axis, side = 1);
axis(at=c(-0.2,axisTicks(c(yMin,yMax),log=FALSE,nint=yticks)), las=1, cex.axis = cex.axis, side = 2);
mtext(side = 1, text = 'time before present', line = xline, cex = cex.lab);
mtext(side = 2, text = ratelabel, line = yline, cex = cex.lab);
for (i in 1:length(poly)) {#
				polygon(x=poly[[i]][,1],y=poly[[i]][,2],col=transparentColor(intervalCol,opacity),border=NA);#
			}
lines(x = rmat$time, y = avg, lwd = lwd, col = avgCol);
xticks=NA
plot.new();
plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));
axis(at=axisTicks(c(1.2*xMin,xMax),log=FALSE,nint=xticks), cex.axis = cex.axis, side = 1);
?axisTicks
##############################################################
##
#	plotRateThroughTime <- function(...)#
##
#	ephy = object of class 'bammdata' or 'bamm-ratematrix'#
#		if bamm-ratematrix, start.time, end.time, node, nslices, nodetype are not used.#
#	useMedian = boolean, will plot median if TRUE, mean if FALSE.#
#	intervals if NULL, no intervals will be plotted, otherwise a vector of quantiles must be supplied (these will define shaded polygons)#
#	ratetype = autodetects diversification vs traits (based on input object 'type'), if 'auto', defaults to speciation (for diversification) or beta (for traits). Can alternatively specify 'netdiv' or 'extinction'. #
#	nBins = number of time slices used to generate rates through time#
#	smooth = boolean whether or not to apply loess smoothing#
#	smoothParam = loess smoothing parameter, ignored if smooth = F#
#	opacity = opacity of color for interval polygons#
#	intervalCol = transparent color for interval polygons#
#	avgCol = color for mean/median line#
#	start.time = start time in time before present to be fed to getRateThroughTimeMatrix#
#	end.time = end time in time before present to be fed to getRateThroughTimeMatrix#
#	node = if supplied, the clade descended from this node will be used.#
#	nodetype = supplied to getRateThroughTimeMatrix#
#	plot = boolean: if TRUE, a plot will be returned, if FALSE, the data for the plot will be returned. #
#	xticks = number of ticks on the x-axis.#
#	yticks = number of ticks on the y-axis.#
#	xlim = vector of length 2 with min and max times for x axis. X axis is time since present, so if plotting till the present, xlim[2]==0. Can also be 'auto'.#
#	ylim = vector of length 2 with min and max rates for y axis. Can also be 'auto'. #
#	add = boolean: should rates be added to an existing plot#
##
#	+ several undocumented args to set plot parameters: mar, cex, xline, yline, etc.#
#	#
#
plotRateThroughTime2 <- function(ephy, useMedian = TRUE, intervals=seq(from = 0,to = 1,by = 0.01), ratetype = 'auto', nBins = 100, smooth = FALSE, smoothParam = 0.20, opacity = 0.01, intervalCol='blue', avgCol='red',start.time = NULL, end.time = NULL, node = NULL, nodetype='include', plot = TRUE, cex.axis=1, cex.lab=1.3, lwd=3, xline=3.5, yline=3.5, mar=c(6,6,1,1), xticks=5, yticks=5, xlim='auto', ylim='auto',add=FALSE, axis.labels=TRUE) {#
	if (!any(c('bammdata', 'bamm-ratematrix') %in% class(ephy))) {#
		stop("ERROR: Object ephy must be of class 'bammdata' or 'bamm-ratematrix'.\n");#
	}#
	if (!is.logical(useMedian)) {#
		stop('ERROR: useMedian must be either TRUE or FALSE.');#
	}#
	if (!any(c('numeric', 'NULL') %in% class(intervals))) {#
		stop("ERROR: intervals must be either 'NULL' or a vector of quantiles.");#
	}#
	if (!is.logical(smooth)) {#
		stop('ERROR: smooth must be either TRUE or FALSE.');#
	}#
	if ('bammdata' %in% class(ephy)) {#
		#get rates through binned time#
		rmat <- getRateThroughTimeMatrix(ephy, start.time = start.time, end.time = end.time, node = node, nslices = nBins, nodetype=nodetype);#
	}#
	if ('bamm-ratematrix' %in% class(ephy)) {#
		if (!any(is.null(c(start.time, end.time, node)))) {#
			stop('ERROR: You cannot specify start.time, end.time or node if the rate matrix is being provided. Please either provide the bammdata object instead or specify start.time, end.time or node in the creation of the bamm-ratematrix.')#
		}#
		#use existing rate matrix#
		rmat <- ephy;#
	}#
#
	#set appropriate rates#
	if (ratetype == 'speciation') {#
		ratetype <- 'auto';#
	}#
	if (ratetype != 'auto' & ratetype != 'extinction' & ratetype != 'netdiv') {#
		stop("ERROR: ratetype must be 'auto', 'extinction', or 'netdiv'.\n");#
	}#
	if (ephy$type == 'trait' & ratetype != 'auto') {#
		stop("ERROR: If input object is of type 'trait', ratetype can only be 'auto'.")#
	}#
	if (ratetype == 'auto' & ephy$type == 'diversification') {#
		rate <- rmat$lambda;#
		ratelabel <- 'speciation rate';#
	}#
	if (ratetype == 'auto' & ephy$type == 'trait') {#
		rate <- rmat$beta;#
		ratelabel <- 'trait rate';#
	}#
	if (ratetype == 'extinction') {#
		rate <- rmat$mu;#
		ratelabel <- 'extinction rate';#
	}#
	if (ratetype == 'netdiv') {#
		rate <- rmat$lambda - rmat$mu;#
		ratelabel <- 'net diversification rate';#
	}#
#
	maxTime <- max(rmat$times)#
#
	#remove NaN columns#
	nanCol <- apply(rate, 2, function(x) any(is.nan(x)));#
	rate <- rate[,which(nanCol == FALSE)];#
	rmat$times <- rmat$times[which(nanCol == FALSE)];#
#
	#generate coordinates for polygons#
	rmat$times <- max(rmat$times) - rmat$times;#
	if (!is.null(intervals)) {#
		mm <- apply(rate, MARGIN = 2, quantile, intervals);#
#
		poly <- list();#
		q1 <- 1;#
		q2 <- nrow(mm);#
		repeat {#
			if (q1 >= q2) {break}#
			a <- as.data.frame(cbind(rmat$times,mm[q1,]));#
			b <- as.data.frame(cbind(rmat$times,mm[q2,]));#
			b <- b[rev(rownames(b)),];#
			colnames(a) <- colnames(b) <- c('x','y');#
			poly[[q1]] <- rbind(a,b);#
			q1 <- q1 + 1;#
			q2 <- q2 - 1;#
		}#
	}#
#
	#Calculate averaged data line#
	if (!useMedian) {#
		avg <- colMeans(rate);#
	} else {#
		avg <- unlist(apply(rate,2,median));#
	}#
	#apply loess smoothing to intervals#
	if (smooth) {#
		for (i in 1:length(poly)) {#
			p <- poly[[i]];#
			rows <- nrow(p);#
			p[1:rows/2,2] <- loess(p[1:rows/2,2] ~ p[1:rows/2,1],span = smoothParam)$fitted;#
			p[(rows/2):rows,2] <- loess(p[(rows/2):rows,2] ~ p[(rows/2):rows,1],span = smoothParam)$fitted;#
			poly[[i]] <- p;#
		}#
		avg <- loess(avg ~ rmat$time,span = smoothParam)$fitted;#
	}#
#
	#begin plotting#
	if (plot) {#
		if (!add) {#
			plot.new();#
			par(mar=mar);#
			if (unique(xlim == 'auto') & unique(ylim == 'auto')) {#
				xMin <- maxTime;#
				xMax <- 0;#
				yMin <- 0;#
				if (!is.null(intervals)){#
					yMax <- max(poly[[1]][,2]);#
				} else {#
					yMax <- max(avg);#
				}#
			}#
			if (unique(xlim != 'auto') & unique(ylim == 'auto')) {#
				xMin <- xlim[1];#
				xMax <- xlim[2];#
				yMin <- 0;#
				if (!is.null(intervals)){#
					yMax <- max(poly[[1]][,2]);#
				} else {#
					yMax <- max(avg);#
				}#
			}#
			if (unique(xlim == 'auto') & unique(ylim != 'auto')) {#
				xMin <- maxTime;#
				xMax <- 0;#
				yMin <- ylim[1];#
				yMax <- ylim[2];#
			}#
			if (unique(xlim != 'auto') & unique(ylim != 'auto')) {#
				xMin <- xlim[1];#
				xMax <- xlim[2];#
				yMin <- ylim[1];#
				yMax <- ylim[2];#
			}#
			plot.window(xlim=c(xMin, xMax), ylim=c(yMin, yMax));#
			axis(at=axisTicks(c(1.2*xMin,xMax),log=FALSE,nint=xticks), cex.axis = cex.axis, side = 1);#
			axis(at=c(-0.2,axisTicks(c(yMin,yMax),log=FALSE,nint=yticks)), las=1, cex.axis = cex.axis, side = 2);#
			if (axis.labels) {#
				mtext(side = 1, text = 'time before present', line = xline, cex = cex.lab);#
				mtext(side = 2, text = ratelabel, line = yline, cex = cex.lab);#
			}#
		}#
		#plot intervals#
		if (!is.null(intervals)) {#
			for (i in 1:length(poly)) {#
				polygon(x=poly[[i]][,1],y=poly[[i]][,2],col=transparentColor(intervalCol,opacity),border=NA);#
			}#
		}#
		lines(x = rmat$time, y = avg, lwd = lwd, col = avgCol);#
	} else {#
		return(list(poly = poly,avg = avg,times = rmat$time));#
	}#
}
plotRateThroughTime2(ephy)
update.packages(ask=F)
